{"pages":[{"title":"Yan Song","text":".homepage-container{ max-width: 960px; } .homepage-content-container{ float: left; } .homepage-photo-container{ width: 360px; float: right; } .homepage-photo-img{ display: block; width: 100%; } .homepage-container::after{ content: \" \"; display: block;; line-height: 0; height: 0; visibility: hidden; clear: both; } Yan Song Assistant Professor Institute of Economic and Social Research Jinan University Education Ph.D. McGill University, Economics, 2011 - 2016 M.A. University of Toronto, Economics, 2010 - 2011 B.A Sun Yat-sen University, China , 2006-2010 Research Interests Health Economics, Education Economics Contact Email: kprinceing@gmail.com","link":"/index.html"},{"title":"Personal CV","text":"You can download my C.V. here","link":"/cv/index.html"},{"title":"Research","text":".page-container{ max-width: 960px; Research StatementMy resarch areas are education and health economics, with a focus on how individuals deviate from rationality when making decisions in education and healthcare contexts. Publications “The Effects of State-level Pharmacist Regulations on Generic Substitution of Prescription Drugs” (with Douglas Barthold, Health Economics, 27.11 (2018): 1717-1737. Link) “Admission Mechanisms and Mismatches between Colleges and Students: Evidence from Large Field Data in China” (with Shiyu Bo, Jing Liu, Ji-liang Shiu, Sen Zhou, Economics of Education Review, 68 (2019): 27-37. Link) “Media Attention and Choice of Major: Evidence from Violence Against Doctors in China”, (with Shiyu Bo, Joy Chen, Sen Zhou, Journal of Economic and Behavior Organization, 170(2020):1-19, lead article, Link) “Noncognitive skills and gender gap in test scores”, (Applied Economics, forthcoming, Link) Working Papers “Sophistication and Cautiousness in College Applications”, (with Kentaro Tomoeda and Xiaoyu Xia, revise and resubmit, Review of Economic Studies, Link)","link":"/research/index.html"}],"posts":[{"title":"Sublime 教程 for Economists","text":"前言随着大数据时代的到来，工作中对数据处理能力的要求越来越高。而不管我们使用何种软件，Python, Stata或是R，都要花大量的时间和编辑器打交道。一个好的编辑器能够显著提高编程效率，降低程序出错的概率。因此熟练掌握一款高效的编辑器是大数据时代的必备技能之一。 然而，大部分非计算机专业的人会因专用文本编辑器较高的学习成本望而却步，转而使用数据软件自带的编辑器，例如STATA do file editor, MATLAB m file editor等。本文旨在为经济学专业的学生和老师，介绍一款文本编辑器，Sublime。本文将着重介绍Sublime的特点，及其与各种自带编辑器在比较之下的优势，而Sublime的安装和操作细节可参看Sublime Text 全程指引 by Lucida 希望你在看完本文后，能找到Sublime的使用窍门,提高工作效率。Happy coding! 插件系统与Package Control虽然Sublime是一个商业开发具有版权的软件，但是它通过插件系统提供了强大的扩展性。目前，共有3,000多名作者开发了超过4,000种插件来满足开发者的不同需求。Package Control就是Sublime用来管理插件的系统。使用Package Control之前需要进行安装，安装方法详见官方文档 使用 Package Control 安装插件通过Package Control安装其他插件极为方便：按下快捷键Ctrl+Shift+P，打开Package Control, 接着键入install，回车选择install Package，接着输入你想要安装的插件，选中安装即可。 我们先简单介绍下几款常用的插件及其主要功能，在接下来的几个部分里我们将对这些插件进行更为详细的介绍。 StataEditor：实现在Sublime里直接调用STATA。 LatexTools：在Sublime内编译Latex文档(需安装Sumatra Pdf Viewer)。 LatexCwl：提供Latex语句的自动填充。 Project系统Sublime的另一个特色就是它的Project系统，为管理项目中的各种类型的文件提供了种较为方便的解决方案。 当我们写论文时，通常会生成多种类型的程序文档，tex文档等。我们也经常需要同时打开多个程序文档来检查代码，会使得大多数编辑器的页面变得冗杂。Sublime设计的project系统有以下几个优势，使得管理一个项目变得轻松。 Project优势 在侧边栏里显示所有文件，而非在主窗口打开。点击一次可以预览该文件，双击打开。 同一个project内可增加多个文件夹:选择Project下面的Add Folder to Project即可,也可以直接将文件夹拖拽至Sublime的侧边栏。 Ctrl+p可以搜索project内任意文件并打开。 Sublime X Stata在介绍完Sublime的基础使用方法及特点之后，我们来展示如何使用Sublime运行STATA程序，以及对比STATA do file editor的优点。 准备工作使用Sublime运行do file，需要几个准备步骤。 首先，需要在Sublime内安装StataEditor,以及Pywin32两个插件。安装方法如下：Ctrl+Shift+P 键入install, 回车选择install Package, 输入StataEditor选择安装；同样的方法安装Pywin32。 其次，需要注册 Stata Automation，官方解释文档 完成了这些准备工作之后，我们就可以在Sublime内运行do file了，只要选中想要运行的部分，按下Ctrl+D即可。 Sublime运行do file的优势我们总结了一些使用Sublime编辑do file的方便之处，更多的优点等待大家在使用中发掘。 强大的Auto-Completion：可以自动补齐变量，函数，程序名称。 Multiple Selection 可以方便的更改多个重复变量名称。 方便的快捷键组合。 Ctrl + ]: 缩进当前行 Ctrl + [: 取消缩进当前行 Ctrl + M: 跳到结束括号；重复操作跳到开始括号 Ctrl + Shift + M : 选择当前圆括号的所有内容 Ctrl + / : 注释/取消注释当前行 Ctrl + Shift + / : 阻止注释当前所选内容(Block comment) Ctrl + Shift + D :重复行 Sublime X LatexLatex是科研人员编辑论文的主要工具。下面我们将介绍如何设置Sublime来运行tex文件，以及对比其他编译器的优势。 准备工作使用Sublime编辑Latex文件需要安装Latextools以及Latexcwl两个插件(电脑中需要安装Miktex)。这两个插件的安装方法跟上面介绍的安装StataEditor的方法类似，这里不再赘述了。 但如果我们希望能够在Sublime中预览pdf文档，需要安装Sumatra Pdf Viewer。下载Sumatra 安装后的配置过程可参考官方文档 Sublime编辑tex文件的优势 解决输入tex环境的重复性工作使用tex写论文或者做slides时经常遇到的一个问题就是需要重复输入代码，例如列表，表格，或者图片环境。LatexCwl插件很好的解决了这个问题。例如，当需要输入一个列表环境时，只需要键入enum, 然后按下tab键，即可完成列表环境的输入。 简化引用文献，表格以及图片的步骤使用Latex写作时，当我们需要进行引用文献，表格或者图片时，要记住每个文章在bibtex中的key，表格的label等。而Sublime提供了更为简洁的解决措施。在引用文献时，输入 \\cite{} 会跳出对话框提示现有bibtex中的参考文献，直接点击想要引用的文献名称即可，也可以直接在对话框里搜索文章或者作者的名字。 Minimap 快速定位文章长度超过几千字后，想要快速跳转到需要修改的部分会不太方便。Sublime的minimap可以提供快速定位，只需要点击minimap中大致对应希望修改的部分即可。 拼写检查功能编辑器中一个容易被忽视，但是其实至关重要的功能就拼写检查。Sublime也提供了这一功能。选中View中的Spell Check即可。","link":"/2019/01/07/Sublime/"},{"title":"Intro Macro 2020","text":"SyllabusSyllabus Slides Mar 4, Week One: Measuring the Macroeconomy slides Mar 11, Week Two: Production and Growth: Mar 18, Week Three: Savings, Investment and the Financial System Mar 25, Week Four: Monetary System and Inflation Apr 1, Week Five: Open-Economy Macroeconomics Apr 8, Week Six: Open-Economy Macroeconomics Continued Apr 15, Week Seven: Aggregate Demand and Aggregate Supply Apr 22, Week Eight: The Influence of Monetary and Fiscal Policy on Aggregate Demand Apr 29, Week Nine: The Short-Run Trade-off between Inflation and Unemployment May 6, Week Ten: Consumption May 13, Week Eleven: Solow Model May 20, Week Twelve: Inequality May 27 Week Thirteen: Inequality Jun 3 Week Fourteen: Class Presentations June 10 Week Fifteen: Class Presentations June 17 Week Sixteen: Class Presentations","link":"/2020/02/26/intro_macro_2020/"},{"title":"STATA教程之：Estout","text":"[TOC] 版本2018.06.13 初稿2018.07.15 第二稿 前言STATA是回归分析的最常用的工具。当我们进行了大量的回归分析之后通常需要解决三个问题。怎样才能直观的展示需要关注的系数？如何才能方便的对比不同回归中的系数？怎样才能生成论文中可以直接使用的高质量的回归表格？本教程将试图对这三个问题给出自己的理解。 本教程将使用STATA中的Estout Package来回答以上三个问题。Estout功能非常强大，其中包括了estout, esttab, estadd等命令。Estout的具体细节介绍可以参考官方介绍文档。 但是由于它的选项非常丰富，学习起来有一定的难度，因此本文旨在对Estout的使用方法进行总结，来达到降低使用estout制作表格的难度的目的。 Estout介绍我们将首先介绍如何使用Estout输出最基本的回归表格，接着介绍如何把描述性数字以及回归中控制的变量类型加入到表格中，最后是如何生成pdf格式的表格。 基本回归表格使用Estout制作基本的表格非常简单，只需要在regress命令后使用esttab即可。 下面我们以STATA自带的auto数据来展示esttab的效果。 123456789101112131415161718192021222324252627282930313233. sysuse auto(1978 Automobile Data). eststo: quietly regress price weight mpg(est1 stored). eststo: quietly regress price weight mpg foreign(est2 stored). esttab-------------------------------------------- (1) (2) price price --------------------------------------------weight 1.747** 3.465*** (2.72) (5.49) mpg -49.51 21.85 (-0.57) (0.29) foreign 3673.1*** (5.37) _cons 1946.1 -5853.7 (0.54) (-1.73) --------------------------------------------N 74 74 --------------------------------------------t statistics in parentheses* p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001. eststo clear 我们用了一个命令就得到了一个简单的回归表格，而这个回归表格已经能够满足清晰的对比不同回归中的相同变量的系数的目的。Esttab之所以如此简单，强大，因为它其实是更为复杂的estout命令的一个wrapper，也就是说当我们使用esttab命令时，其实已经使用了STATA设计好的初始设置。例如，回归系数，标准误差的小数点默认为三位，以及表格中会加入观测值数量等。当然，这个表格还不能满足我们的所有需求。当我们希望更为丰富的表格内容时该如何做呢？ 加入描述性数据，以及控制变量类型可以加入到回归表格中的描述性数据分为两类：回归本身返回的数据，例如R-Square, 观测值数量等；需要另外计算加入到回归表格中的数据，例如因变量的均值，控制变量类型等。 加入回归返回的数据将回归本身返回的数据加入到表格的方法相对简单，只需要使用esttab中的选项stats即可。例如，当我们需要加入R Square和回归的观测值时，可以加入stats(r2 N, labels(“R Square” “Num of Obs”))。其中，r2，N分别代表了要加入的数据，而labels中的内容为数据的标签。具体效果可见下图。123456789101112131415161718192021222324 .esttab, stats(r2 N, labels(&quot;R Square&quot; &quot;Num of Obs&quot;))-------------------------------------------- (1) (2) price price --------------------------------------------weight 1.747** 3.465*** (2.72) (5.49) mpg -49.51 21.85 (-0.57) (0.29) foreign 3673.1*** (5.37) _cons 1946.1 -5853.7 (0.54) (-1.73) --------------------------------------------R Square 0.293 0.500 Num of Obs 74 74 --------------------------------------------t statistics in parentheses* p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001 加入其他信息如果所需要加入回归表格中的信息不是回归中返回值时，我们需要用到estout package中的estadd命令。例如，当需要加入因变量的均值时，我们可以使用以下命令12sum price estadd r(mean) 我们也常常需要在回归表格中标注所控制的变量的类型，这一步骤也同样的可以使用estadd来实现。例如，当我们希望在上述部分回归中控制车辆是否是外国品牌时，我们可以在回归表格中加入一行来显示每个回归是否控制了该变量。 1estadd local Foreign_FE = &quot; &quot;, replace 完整代码，以及输出的表格效果可见下图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 sysuse auto,clear reg price trunk headroom length weight estimates store est1 sum price estadd r(mean) estadd local Foreign_FE = &quot; &quot;, replace reg price trunk headroom length weight i.foreign estimates store est2 sum price estadd scalar ymean = r(mean) estadd local Foreign_FE = &quot;X&quot;, replace . esttab, stats(Foreign_FE ymean r2 N, ///&gt; labels(&quot;Foreign FE&quot; &quot;Dep Mean&quot; &quot;R Square&quot; &quot;Num of Obs&quot;))-------------------------------------------- (1) (2) price price --------------------------------------------trunk 114.1 63.31 (1.04) (0.68) headroom -711.6 -606.2 (-1.60) (-1.62) length -101.7* -89.03* (-2.41) (-2.52) weight 4.753*** 5.780*** (4.24) (6.04) 1.foreign 3526.8*** (5.51) _cons 11488.5* 5340.2 (2.53) (1.35) --------------------------------------------Foreign FE X Dep Mean 6165.3 6165.3 R Square 0.372 0.566 Num of Obs 74 74 --------------------------------------------t statistics in parentheses* p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001 制作tex文档上述表格都是在STATA窗口中的显示效果，并不是我们的最终目的。我们希望能够将表格制作和文章写作打通起来，实现完全自动化，从进行回归分析，到将表格加入到文章中，不需要进行任何手动的复制粘贴。将这一过程自动化的目的，是在不断修改回归的过程中，减少人为出错的概率。为了达到这个目的，我们需要使用estout 中的using .tex， 以及prehead, postfoot这几个选项。using x.tex将输出结果更改为tex格式，而prehead, postfoot分别包括了使得tex文档能够直接编译成pdf的tex代码。具体代码可见下图。 1234567891011121314151617181920212223242526272829#delimit ; esttab est1 est2 using estout_eg.tex, replace style(tex) booktabskeep(trunk headroom length weight 1.foreign) stats(Foreign_FE ymean r2 N, labels(&quot;Foreign FE&quot; &quot;Dep Mean&quot; &quot;R-Squared&quot; &quot;N&quot;) fmt(0 3 3 0)) // content options b(3) se(3) star(* 0.1 ** 0.05 *** 0.01) // content formating options mlabels(,none) numbers // column heading optionslabel varlabels(1.foreign &quot;Foreign&quot;) // row head formating optionsprehead( // tex code needed to compile document \\documentclass[leqno,11pt]&#123;article&#125; \\usepackage&#123;booktabs&#125; \\usepackage&#123;tabularx&#125; \\begin&#123;document&#125; \\begin&#123;table&#125;[h] \\def\\sym#1&#123;\\ifmmode^&#123;#1&#125;\\else\\(^&#123;#1&#125;\\)\\fi&#125; \\caption&#123;Using Estout to Output Regression Coefficients&#125; \\begin&#123;center&#125; \\begin&#123;tabular&#125;&#123;l c c&#125; \\toprule) postfoot( // more tex code needed to compile document \\end&#123;tabular&#125; \\end&#123;center&#125; \\end&#123;table&#125; \\end&#123;document&#125; ) ;#delimit cr STATA在执行完上述代码后，会生成一个estout_eg.tex的文档。通过Latex编译这个文档，我们可以得到如下图所示的 代码下载链接完整版本PDF下载链接 版权声明","link":"/2019/01/07/estout/"},{"title":"Talk on coding practice for IESR, Jinan","text":"SlidesSlides","link":"/2019/05/17/talk/"},{"title":"Sublime Tricks","text":"添加MATLAB Build System在Sublime中选择Tools -&gt; Build System -&gt; New Build System，系统会创建一个JSON文件，根据不同系统输入以下内容 1234&#123; &quot;cmd&quot;: [&quot;/Applications/MATLAB_R2017b.app/bin/matlab&quot;, &quot;-nosplash&quot;, &quot;-nodesktop&quot;, &quot;-r&quot;, &quot;run(&apos;$file_name&apos;)&quot;], &quot;selector&quot;: &quot;source.m&quot;&#125; 上面给出的路径是我的电脑中的配置，需要根据电脑中MATLAB安装路径来修改。其中，matlab -nosplash -nodesktop -r ${file_base_name}表示启动matlab，并运行某个.m文件。-nosplash表示不加载启动界面；-nodesktop表示不加载GUI界面；-r表示运行Matlab命令行（MATLAB_command）；filename表示文件名，但不包含文件扩展名，如.m等。设置完成后保存即可。 保存好后可以打开一个.m文件，在Build System下选择刚新建的配置，按下快捷键Ctrl+B，Sublime会打开MATLAB_command并编译当前文件。但是目前的方法仍然有缺陷，每次Build都会产生一个新的命令行界面，相当于每次都重新启动了一次MATLAB_command。 同步Sublime设置当我们使用多台电脑工作时，如果需要在每台电脑上重复安装所有的Sublime package将是非常麻烦的工作。Package Control提供了一种简便的同步方式。 首先找到Packages/User/文件夹下面的Package Control.sublime-settings文件，然后将这个文件复制到其他电脑的同样位置下。重新启动Sublime时，Package Control将会安装所有缺失package的正确版本。当然，这样的方法不能够提供实时同步的功能。如果你希望不同电脑上的Sublime能够实时同步，有两种方法，一是使用git,二是使用drobox的symbolic link。第一种方法要方便的多。具体可以参考https://packagecontrol.io/docs/syncing","link":"/2019/01/20/more on sublime/"},{"title":"Talk on coding practices for Central University of Finance and Economics","text":"SlidesSlides","link":"/2019/12/07/talk_cufe/"},{"title":"Tuning MATLAB Code","text":"写高效率的MATLAb code和写好英文文章的最核心，最重要的思路是完全一样的： 不要重复 (avoid redundancy). 做到了这一点，代码的效率会得到保障，也能让读者更好的理解自己英文文章的目的。 这一个简单思路之所以如此重要是因为大部分MATLAB code的bottleneck都是重复次数非常多的for loop， 而for loop中即使一个很小的计算，在几万次的重复下也会对整体程序的效率起到很大的影响。因此，写好MATLAB code的关键就是如何避免重复计算。基于这点思路，下面具体介绍三类如何避免重复计算的方法 Move loop-invariant code out of the loop如果一个计算在每次loop时不发生变化，那么这个计算就应该被调整到for loop之外。这个思路虽然简单，但是有的时候并不是特别容易发现重复的计算，特别是这个计算是在另外一个函数中进行时。 下面举例说明： ‘’’ for loopIDX = 1:1000 array =1:100; process(array,loopIDX); end function process(array, loopIDX) arrayLen = length(array); for arrayIDX =1:arrayLen doSomething(arrary(arrayIDX),loopIDX); end end ‘’’这里的redundancy不是特别容易发现，arrayLen是在 process 函数里面计算的，但是这个变量不会因为loopIDX的改变而变化， 因此不需要重复计算。 优化后的代码如下 ‘’’ array =1:100; arrayLen = length(array); for loopIDX = 1:1000 process(array,arrayLen,loopIDX); end function process(array,arrayLen,loopIDX) for arrayIDX =1:arrayLen doSomething(arrary(arrayIDX),loopIDX); end end ‘’’ Minimize Dereferencing不仅是不必要的计算需要尽量减少，其他一切会消耗计算时间的代码都需要优化。这里面就包括了：overhead of calling function and referencing. 每次call function和指代矩阵元素，不仅是函数计算和矩阵运算会耗费时间，而且会有额外的overhead的成本。 下面举例说明 12345678910111213a = [0,0];for idx =1:1e8 a(2)=a(2)+idx;enda = [0,0];b = 0;for idx =1:1e8 b = b +idx;enda(2) = b; 这几行代码只是对a(2)进行一个累计的加总，但是第一种方法由于每个loop里面都需要进行通过index找到a(2)具体值的计算，而第二种方法通过使用一个temporary variable b，避免了每次的索引运算，可以将运算时间从0.9秒缩短到0.5秒。 Vectorization作为一个矩阵运算语言，MATLAB进行矩阵计算通常比通过for loop进行计算要更有效率，因此使用矩阵语言代替for loop通常能够节约计算时间，这种方法被统称为vectorization。下面，我们举一个例子，来介绍vectorization的思路。 假设，我们有一个班级的学生成绩，以vector form储存。我们需要在这些学生中抽出4人组成一个小组,得到一个储存了每种可能的矩阵，每行对应抽中学生的成绩。 下面代码可以通过for loop来实现这一目的。 123456789101112ticdata = rand(5,1);for i =1:1e5 c_mod = nchoosek(1:5,3); exp_cbnt = zeros(size(c_mod, 1), 3); exp_cbnt(:,1) = data(c_mod(:,1),1); for k = 2:3 exp_cbnt(:,k) = data(c_mod(:,k),1); endendtoc 使用vectorization的方法如下。这里的思路是先计算最终需要得到的矩阵的row vector form (one dimension)，再通过reshape得到最终的目标矩阵。 使用vectorization的方法会比第一种for loop的方法节约大概百分之十的计算时间，loop次数越多节约的时间会越明显。123456789101112ticfor i =1:1e5 c_mod = nchoosek(1:5,3); c_mod_length = size(c_mod, 1); c_mod_vec = reshape(c_mod,c_mod_length*3,1); exp_cbnt_vec = data(c_mod_vec,1); exp_cbnt_b = reshape(exp_cbnt_vec,c_mod_length,3);endtoc isequal(exp_cbnt,exp_cbnt_b) Vectorization的方法还有很多，这里无法一一列举，但是重要的是当我们看到for loop时，应该立刻去想是不是有可能用矩阵的方法来表达,然后再测试对比两种方法所花的时间.Matlab已经能够对for loop进行非常高效的优化了，所以并不是vectorization一定会节约时间。","link":"/2019/05/31/tuning matlab code/"},{"title":"STATA教程之：Tabout","text":"[TOC] 版本2018.06.24 初稿 2018.07.19 第二稿 2018.08.03 终稿 前言描述性表格(Summary Statistics Table)，作为每篇论文中最先亮相的表格，它的设计和内容在很大程度上决定了读者对文章的第一印象。Latex虽然可以制作出专业的表格，但是tex环境中输入各类型的描述性数字枯燥且容易出错。那么如何快速高效的制作出专业的描述性表格呢？ Stata中可以用来做描述性表格的命令众多，例如，tabulate, table, tabstat等。而本文将介绍的主要工具为Tabout命令。Tabout和上述提到的命令相比，能够制作更多类型的表格，且能够快捷的输出表格的tex code，从而方便的将表格插入到完整的tex文档中。 本文将介绍如何通过使用Tabout命令，设计出一个简洁而又内容丰富的描述性表格。 TaboutTabout的核心思想是将描述性表格分成了两类：frequency table和summary table. Frequency table, 顾名思义就是变量取值的频率分布表，而summary table则是输出例如均值，中位数等样本统计数字的表格。两种表格都可以分为oneway, 和twoway两种类型。在Tabout的逻辑下，可以通过一套语法，细调部分选项，来生成这几种表格。下面我们通过举例来说明tabout的完整逻辑，以及语法细节。 Frequency TableTwoway Frequency Table我们使用STATA自带的cancer.dta数据来制作frequency table。数据中的两个变量，drug, died，分别记录了病人使用的药的种类，以及是否死亡。下图统计了使用不同药物种类的人数，以及使用各个药物后的死亡人数的分布。我们将分别对输出这个表格的Stata Code进行详细解释。 1234567#delimit ; //change delimiter to ;tabout died drug using freq_two.tex, replace style(tex) c(freq col cum) // column contentclab(Freq Col_Pct Cum_Pct) f(0 0 0) // column head and content formatingtitle(Table: Twoway Frequency Table) fn(Source:auto.dta) // title and footnotetopf(table_top.tex) botf(table_end.tex) ; // tex codes#delimit cr 第一行 tabout died drug using freq_one.tex, replace style(tex) 是基本设置，即选择所要输出的tex file，以及设定输出的格式为tex。 值得讨论的是 died drug这两个变量的顺序。 Tabout将变量分成列变量，和行变量，并且规定最后一个变量为行变量。行变量的意思很直白，就是每个变量的值在表格中以行的形式出现。 这个设定的好处是我们可以设置多个列变量，同时和行变量进行cross tabulation。 第二行c()是frequency table的核心选项，即表格中要输出的内容：freq, col, cum分别代表了频数，列比，和累计百分比。 第三行是输出类容的格式设定。clab的含义是输出内容的标题，即频数列应该被标记为Freq, 而列比应该被标记为Col_Pct。 f选项设置了每一类型的数值应当保留的小数点位数。 值得指出的是，tabout在行标题上的逻辑也较为独特，需要理解后才能很好掌握。 Tabout设置了3级行标题，第一级标题是行变量的名称，第二级行标题是行变量的具体取值，第三季标题是tabulate的内容，例如在这里是频数，列比例，和累计比例。这三级标题的设置可以通过h1, h2和h3来设置。 clab同样可以设置第三级标题，区别是clab可以改变所有panel里面的第三级标题，而h3只能改变第一个panel。 第四行为表格标题，以及脚注的设定。 第五行是整个使用tabout的workflow的核心。tabout输出的虽然是tex code，但是并不能直接用来编译。不能编译的结果就是我们必须手动的添加topf 以及botf至tabout的输出结果中。而当我们需要经常的调整表格内容时，每一次都需要手动添加这些内容显然非常的繁琐。而topf 以及botf使这一手动过程可以自动化。 tof和botf的内容是非常简单的tex代码，只是用来可以直接编译生成的latex表格代码，具体内容可见下面的code block。 tof文件的内容为： 1234\\documentclass[leqno,11pt]&#123;article&#125;\\usepackage&#123;booktabs&#125;\\usepackage&#123;tabularx&#125;\\begin&#123;document&#125; botf文件的内容是： 1\\end&#123;document&#125; 执行上述Stata命令之后，我们会得到一个tex文档。编译tex文档即可得到如下图所示的表格。 Oneway Frequency Table虽然入门有难度，但是Tabout的好处是在理解了它的逻辑之后，稍微改动一些选项就可以生成其他类型的表格。例如，当我们需要生成oneway frequency table时，只需要在选项中加入oneway即可。 1234567#delimit ; //change delimiter to ;tabout died using freq_one.tex, replace style(tex) onewayc(freq col cum) // column contentclab(Freq Col_Pct Cum_Pct) f(0 2 2) // column head and content formatingtitle(Table:Oneway Frequency Table) fn(Source:auto.dta) // title,footnotetopf(table_top.tex) botf(table_end.tex) ; // tex codes#delimit cr Summary Table类似的，我们只需要微调选项既可以使用tabout生成summary table。 下面我们举例说明。 Twoway Summary Table123456sysuse auto, cleartabout rep78 foreign using table10.tex, replace ///style(tex) font(italic) c(mean weight) f(0c) sum ///twidth(9) h1(Car type (mean weight in lbs.)) h3(nil) ///title(Table 10: Simple twoway summary table of means) ///fn(auto.dta) 第三行是微调的核心，加入了sum选项，即表明这里需要生成的是summary table, 而不是frequency table。另外c()选项中的mean weight说明了我们需要的数字是车辆的平均重量。上述代码生成的表格如下图。 Oneway Summary Table类似的，我们也可以生成oneway summary table。具体可见下面的代码和图，不再赘述。12345678sysuse auto, cleartabout foreign rep78 using table12.tex, replace ///style(tex) font(bold) twidth(13) sum npos(tufte) ///c(mean mpg mean weight mean length median price ///median headroom) f(1c 1c 1c 2cm 1c) h2(Mean Median) ///h2c(3 2) clab(MPG Weight_(lbs) Length_(in) Price ///Headroom_(in)) title(Table 12: Oneway summary table ///\\\\ with multiple summary measures) fn(Source: auto.dta)","link":"/2019/01/07/tabout/"},{"title":"Maximum Likelihood Estimation in STATA","text":"STATA本身有很多estimator是通过MLE方法估计的，例如logit, probit等。在这些模型之外，STATA同时提供了ML syntax来拓展可以估计maximum likelihood模型。下面我们举例子说明ML syntax的用法。 LF Estimator当整体样本的Log likelihood可以通过每个样本点的log likelihood累加得到时，STATA认为这类模型符合线性约束(Linear Form Restriction)，可以使用STATA ML syntax中的lf方法来估计这类模型。我们将使用lf方法来估计四种常见的模型: binary logit, binary probit, OLS, and mixed logit model. Logit ModelLog Likelihood formula for Logit Model：prob(y=1) = exp(xb)/(1+exp(xb)) Code:‘’’ program logit_lf args lnfj theta tempvar p local y $ML_y1 quietly gen `p&apos; = exp(`theta&apos;)/(1+exp(`theta&apos;)) quietly replace `lnfj&apos; = ln(`p&apos;) if `y&apos; == 1 quietly replace `lnfj&apos; = ln(1-`p&apos;) if `y&apos; == 0 end sysuse auto, clear ml model lf logit_lf (eq1: foreign = weight length) ml maximize ‘’’ 几个要注意的点： + args 是STATA提供的一种parse的工具，是把positional argument变成指定的local。例如，ml提供的第一个argument通过args变成了local lnfj，而在剩下的程序里，都将以`lnfj&apos;的形式出现。 + program 中的theta是所有x和系数的linear combination。这是使用lf方法最方便的地方，不需要考虑单独的系数大小，而是把系数的linear combination放在一起考虑。 + lnfj 是每个observation 的log likelihood. + $ML_y1 是第一个公式中的 dependent variable，以global 的形式存在。 + 所有program 中使用的新的变量要用tempvar + ml model lf logit_lf (eq1: foreign = weight length) 这一行是定义模型，即使用lf方法的logit_lf模型，模型中的y是foreign，而解释变量包括了weight和length。 + ml maximize 这一行是对上述模型进行求解，计算出对应最大loglikelihood的参数。 Probit Model类似地，我们可以通过lf方法估计probit模型：‘’’ program probit_lf args theta lnfj local y $ML_y1 quietly replace `lnfj&apos; = ln(normal(`theta&apos;)) if `y&apos; == 1 quietly replace `lnfj&apos; = ln(-normal(`theta&apos;)) if `y&apos; == 0 end ‘’’ Linear Regression Model线性回归模型(homoskedastic standard errors)也可以通过lf方法实现：‘’’ program ols_lf args lnfj theta std local y $ML_y1 quietly replace lnfj&#39; = ln(normalden(y’,theta&#39;,std’)) end ml model lf ols_lf (eq1: mileage = weight length) (eq2:) * ml model lf ols_lf (eq1: mileage = weight length) /eq2 ml maximize ‘’’ 要注意的点： Linear regression model和前面的logit probit模型不同的地方在于：线性回归模型的log likelihood不能通过一个theta(linear combination of variables)来表达，而是由两个系数同时决定的，一个是所有变量的线性组合，一个是残差项的standard deviation。因此，我们需要在写函数，和使用ml model时候都要做出相应的调整。首先，ml model 要加入第二个公式，即(eq2:)。这里，由于模型的假设包括了homoskedasticity,残差项的std不和任何解释变量相关，因此(eq2:)中不需要包括任何解释变量，只需要一个constant变量即可。 当放松homoskedasticity的假设时，我们只需要稍微修改ml model中的eq2部分即可。 Mixed Binary Logit ModelLogit model虽然直观易估计，但是对于individual preference有比较强的限制。因此，我们可以估计一个mixed binary logit model，来解决这个问题。但是mixed logit model的log likelihood表达式没有closed form solution,因此只能通过simulation来解决，而STATA的ML syntax可以较好的提供simulation的方法。 // Simulate data for estimation /* x~N(0,1) beta1 = 1 beta2 ~ N(1,1) epsilon~ extreme value distribution y = (beta_1+ beta_2*x +epsilon&gt;0) */ clear set obs 1000 set seed 10101 gen x = rnormal() gen beta_1 = 1 gen beta_2 = rnormal(1,1) gen u = uniform() gen epsilon = log(u)-log(1-u) gen y = (beta_1 + beta_2*x+epsilon) &gt; 0 forvalues i = 1/1000{ quietly gen draw_`i&apos; = uniform() } program mixed_logit args lnfj beta_1 beta_2 std tempvar p sim_f sim_avg_f quietly gen `sim_avg_f&apos; = 0 quietly{ forvalues i = 1/1000{ gen `p&apos; = exp(`beta&apos;1+`beta_2&apos;*x + /// `std&apos;*`draw_i&apos;*x)/(1+exp(`beta&apos;1+`beta_2&apos;*x + `std&apos;*`draw_i&apos;*x)) gen `sim_f&apos; = `p&apos; if $ML_y1 == 1 replace `sim_f&apos; = 1- `p&apos; if $ML_y1 == 0 replace `sim_avg_f` = `sim_avg_f` + `sim_f`/1000 } replace `lnfj&apos; = ln(sim_avg_f) } end ml model lf mixed_logit (beta_1:y = )(beta_2:x)(std:) ml maximize 这里需要注意的是： Log likelihood是一千次Simulation的平均。 由于Log likelihood不能够通过所有变量的线性组合来表示，我们需要把系数拆分成三个部分，常数项的系数，变量X的系数的均值，变量X的std.这样的拆分不影响我们使用lf方法，因为样本的log likelihood仍然是由所有的样本的Log likelihood加总得到。 D0 Estimator上述lf estimator只适用于样本的log likelihood仍然是由所有的样本的Log likelihood加总得到的情况，当上述条件不成立时，我们需要使用STATA提供的d0 estimator. D0 estimator的特点是我们需要在模型中提供整体样本的log likelihood，而不是每个单独样本点的log likelihood。下面我们用Conditional logit model来说明d0 estimator的用法。 Conditional Multinomial Logit ModelModel:Individual: indexed by iChoice situation: indexed by jU_ij = XB+ epsilon, epsilon~extreme value distributionLog Likelihood if choice j is chosen: exp(x_kb)/\\sum(exp(x_jb)) Code: cls program drop _all webuse choice,clear gen japan = car==2 gen europe = car ==3 program clogit_sch version 14 /* model: lnfi = exp(xb)/(\\sum exp(xb)) */ args todo b lnf tempvar xb e_xb sum_e_xb lnfj // local group_id $ML_id local y $ML_y1 mleval `xb&apos; = `b&apos;, eq(1) sort id quietly{ gen `e_xb&apos; = exp(`xb&apos;) bysort id: egen `sum_e_xb&apos; = total(`e_xb&apos;) gen double `lnfj&apos; = ln(`e_xb&apos;/`sum_e_xb&apos;) mlsum `lnf&apos; = `lnfj&apos; if `y&apos; == 1 } end global ML_id id ml model d0 clogit_d0 (eq1: choice = dealer japan europe) ml check ml max 需要注意的是： mleval: 计算系数b&#39;带来的linear combination的xb’。 mlsum: 计算所有相关的loglikelihood的总和。 mlcheck：用来对ml model进行debug。 和STATA提供改的asclogit的结果进行对比 webuse choice,clear set more off gen japan = car==2 gen europe = car ==3 cd C:/Users/yan/Dropbox/college_entrance_exam/program/2018.12 program drop _all global ML_id id ml model d0 clogit_sch (eq1: choice = dealer japan europe,noconstant) ml check ml max asclogit choice dealer, case(id) alternatives(car) 这里需要指出，asclogit会在后台生成choice specific fixed effect,而我们的estimator需要自己生成这些变量，加入到模型中，但是好处是我们的模型更加flexible。 另外几个很有用的ml command是 ml query, ml report, ml init,和 ml graph。ml query是显示目前处理的模型，包括了每条equation,变量，和系数的初始值。ml report会显示目前的系数vector, gradient vector, negative Hessian, and maximization direction。ml init用来设置模型参数的初始值，例如 ml init 1 2 -2, copy。Ml graph可以用来检测潜在的convergence issue。Newton-Rhapson 是默认的maximization routine，可以通过technique()选项来尝试其他方法，例如bhhh, dfp, and bfgs等。","link":"/2019/01/12/mle_summary/"}],"tags":[{"name":"SUBLIME","slug":"SUBLIME","link":"/tags/SUBLIME/"},{"name":"Teaching","slug":"Teaching","link":"/tags/Teaching/"},{"name":"STATA","slug":"STATA","link":"/tags/STATA/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"}],"categories":[]}